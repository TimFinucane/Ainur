package algorithm.heuristics.lowerbound;

import common.graph.Graph;
import common.graph.Node;
import common.schedule.Schedule;

import java.util.HashSet;

/**
 * A pruner that calculates the lower bound generated by filling all remaining space with tasks
 */
public class FillTimeBound implements LowerBound {

    @Override
    public int estimate(Graph graph, Schedule schedule, HashSet<Node> nodesToVisit) {
        // Get all remaining space
        int space = 0;

        for(Node node : graph.getNodes()) {
            if(!schedule.contains(node))
                space += node.getComputationCost();
        }

        // Now compute what space we have to fill in the processors who's length is less than max
        int latestTime = schedule.getEndTime();
        for(int processor = 0; processor < schedule.getNumProcessors(); ++processor)
            space -= (latestTime - schedule.getEndTime(processor));

        return Math.min((int)Math.ceil(space / (double)schedule.getNumProcessors()), latestTime);
    }
}
